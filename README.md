# Tasker
Проект, выполненный в рамках дисциплины "Проектирование информационных систем" студентами 4 курса ИРИТ-РТФ.   

<hr></hr>  

**Описание проекта**
=====================
Распределенный сервис для постановки, выполнения и мониторинга
абстрактных задач с возможностью контроля времени жизни процесса (TTL, Time-to-Live).

<hr></hr>  

**Описание реализации**
=====================
Tasker состоит из трёх микросервисов:
* Tasker.Backend - создание/изменение/просмотр задач осуществляется через REST-API.
* Tasker.Identity - аутентификация, авторизация.
* Tasker.Worker - обработка созданных задач.
Обработчиков задач может быть неограниченное количество (горизонтальное масштабирование).

Стек
-----------------------------------
* Микросервисы разработаны на C# с использованием ASP.NET Core (net8.0)
* БД: PostgreSQL 17.2
* Брокер сообщений: Kafka
### Важные фреймворки:
* Microsoft.EntityFrameworkCore
* Duende.IdentityServer
* AutoMapper
* MediatR
* FluentValidation
* Swashbuckle.AspNetCore
* Microsoft.Extensions.Logging 

Ролевая модель
-----------------------------------
* User - доступ к базовым командам для взаимодействия с задачами
* Admin - доступ к служебному API

API Tasker: доступные методы для взаимодействия с задачами
-----------------------------------
  ![image](https://github.com/user-attachments/assets/32dc7422-0b08-463d-90b0-7e055b174558)
  
* GET /api/Task/ - получение информации о всех задачах, созданных текущим пользователем
* POST /api/Task/ - создание задачи
* GET /api/Task/{id} - получение информации о задаче по её Id (только для своих задач)
* PATCH /api/Task/request/{id} - запросить выполнение задачи (служебный запрос для Worker, доступен только учётным записям с ролью "Admin")
* GET /api/Task/{id}/result - получение информации о результате выполнения задачи по её Id (только для своих задач)


Логика работы
-----------------------------------
1. Пользователь создаёт задачу, указывая её тип, TTL (в ms) и параметры (например: длина генерируемой последовательности).
2. Задача добавляется в таблицу ParametrizedTasks со статусом "CREATED" и отправляется в брокер сообщений.
3. Обработчик задач получает информацию о задаче из брокера и запрашивает разрешение на выполнение задачи у Tasker.Backend.
Если получен положительный ответ - обработчик начинает выполнение задачи. С этого момента начинается отсчёт TTL.
Статус задачи меняется на "RUNNING", записывается время начала выполнения задачи и имя обработчика задачи. 
Если задача успешно выполнена за указанное время - обработчик отправляет сообщение с результатами в брокер.
Если превышен TTL или произошла ошибка - обработчик отменяет выполнение задачи, в брокер ничего не отправляется.
4. Tasker.Backend читает из брокера сообщение с результатом выполнения задачи. Если сообщение с результатом получено позже, чем время начала выполнения задачи + TTL - задача помечается "CANCELLED", добавляется время окончания обработки задачи, результат выполнения в таблицу при этом не записывается.
Если же результат получен в пределах установленного TTL - задача помечается "FINISHED", добавляется время окончания обработки задачи, результат выполнения записывается в таблицу ParametrizedTasksResults.
5. Tasker.Backend регулярно отслеживает состояние задач. Если у задачи установлен статус "RUNNING", но по ней не пришёл результат в рамках установленного TTL - задача помечается "CANCELLED", добавляется время окончания обработки задачи.
6. Tasker.Backend регулярно отправляет в брокер сообщения, о задачах, которые созданы, но ещё не взяты в работу (задачи со статусом "CREATED").

ВАЖНО
-----------------------------------
* На данный момент реализовано две операции: GENERATE_LOGIN и GENERATE_NUMBER. Если у задачи будет Type, отличающийся от этих, - обработчик не возьмёт её в работу.
* Текущая реализация предусматривает передачу параметров для операций, но, на данный момент передаваемые параметры нигде не используются. GENERATE_LOGIN создаёт последовательность длины 10, состоящую из цифр и латинских букв. GENERATE_NUMBER генерирует восьмизначное число int.
* У операций симулирована длительность выполнения при помощи await Task.Delay(...) .
* За распределение нагрузки отвечает брокер сообщений. В данном случае используется Kafka. Для горизонтального масштабирования топики необходимо поделить на нужное число partition.

**Настройка и запуск**
=====================
1. Разверните PostgreSQL сервер.
2. Разверните Kafka. 
3. При необходимости измените в appsettings.json у Tasker.Backend параметры подключения к базе данных, Kafka и серверу аутентификации, а также периодичность переотправки задач в Kafka и обновления информации о задачах в базе данных.
![backend-settings](https://github.com/user-attachments/assets/6509d66e-045c-4e00-9050-3c831f9d36c9)
4. При необходимости измените в appsettings.json у Tasker.Worker параметры подключения к Kafka, серверу аутентификации, а также credentials для доступа к API. Можно изменить задержку, с которой worker переходит к следующей задаче, лимит одновременно обрабатываемых задач и имя обработчика.
![worker-settings](https://github.com/user-attachments/assets/d645f1c0-fe3a-4800-ac5f-eba11f77bfe9)
5. При необходимости измените в appsettings.json у Tasker.Identity параметры подключения к базе данных.
![authenticationserver-settings](https://github.com/user-attachments/assets/2e787de8-1235-44ce-b456-f6eb6b83f04c)
6. Запустите Tasker.Identity, Tasker.Backend, Tasker.Worker.
7. Создайте необходимые учётные записи. Для этого перейдите по {Tasker.Identity address}/Auth/Register?ReturnUrl=Login (P.S.: ReturnUrl должен быть указан обязательно) и заполните необходимые поля. Обязательно нужно создать учётную запись для worker (данные указывали ранее в appsettings.json у Tasker.Worker).
   При создании учётной записи для worker обязательно ставить галочку Full Access (у учётной записи будет полный доступ к API Tasker.Backend).
   ![image](https://github.com/user-attachments/assets/83066771-b4ba-45db-a1ab-7956f2a85f80)
8. Получите access token для своей учётной записи. Для этого можно воспользоваться Postman. Отправьте POST запрос на {Tasker.Identity address}/connect/token . Запрос должен содержать следующую информацию в Body x-www-form-urlencoded:
   * grant_type: password,
   * username: логин вашей УЗ,
   * password: пароль вашей УЗ,
   * client_id: tasker_backend,
   * scope: openid profile TaskerWebAPI
   Скопируйте токен из ответа.

   ![image](https://github.com/user-attachments/assets/c434505f-d7a4-46e7-934b-978a7bc794ea)

10. Перейдите в Swagger по адресу {Tasker.Backend address}/index.html . Нажмите "Authorize", вставьте token, полученный на прошлом этапе, в поле "Value". Нажмите "Authorize".
    ![image](https://github.com/user-attachments/assets/2683fb83-70a1-473f-b3c0-035b80f666e5)

<hr></hr>  

**TODO**
=====================
* Вынести статусы задачи в отдельный enum. Сейчас они проверяются напрямую через '=='.
* Queries должны возвращать View Model. Некоторые возвращают доменную сущность.
* Изменение неймингов внутри Tasker.Worker. Микросервис скопирован с Tasker.Backend, поэтому все namespace'ы и т.д. совпадают с Tasker.Backend.
* Улучшение архитектуры кода (например: абстрагировать зависимость от фреймворков через интерфейсы). Стремиться к чистой архитектуре.
* В целом рефакторинг кода всех трёх микросервисов.
* Передача параметров в операции.
* Docker
* Везде должно быть безопасное соединение. На данный момент Kafka не настроена на использование сертификата.
* Валидация типа задачи в момент отправки. На данный момент валидации нет. Если у задачи Type, который не обрабатывает Worker - задача вечно будет висеть в статусе "CREATED".
* Документация.
* Логирование. Сейчас логируются очень мало информации. Также логируются далеко не все ошибки. Нет сохранения логов в файл.

и ещё всякое разное...
